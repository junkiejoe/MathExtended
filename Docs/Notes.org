
* Finding the corners of a rectangle.

So we want to find the corners of a rectangle. We have the origin, the length and the width. When we have an unrotated rectangle, we can easily find the corners.

Let:
- W (width) H (height)
- A (Top left corner) = (-W/2, H/2)
- B (Top right corner) = (W/2, H/2)
- C (Bottom left corner) = (-W/2, -H/2)
- D (Bottom right corner) = (W/2, -H/2)

Now if we have an angle \Theta on our rectangle, this won't work. So what can we do? Well you might think to just rotate all the points. And this works perfectly fine. We can calculate cos(\Theta) and sin(\Theta) once, reuse them for every corner, and get good enough results. However, there is a better method. 

Lets look at two important properties of a rectangle.
- The opposite sides are parallel to eachother
- The interior angle of each corner is 90°.

The components of the right angle corner are A, O, and R.
Where:
- A is the adjacent vector
- O is the opposite vector
- R is the sum of A and O

O will form a right angle from A. So all we need to do is get A, the point 90° from A.

- O = (-A_{y}, A_{x})
(Tip: If you want to get the left angle, don't neg A_{y})

So if \Theta = 0, then

- A = (cos\Theta, sin\Theta) = (1, 0)
- O = (-A_{y}, A_{x}) = (0, 1)
- R = A + O = (1, 1)

Now that we have A and O we can use them for every corner. If you want the bottom left, just do -R, and if you want the bottom right do (-A) - O. Lets look at the full equation to get all corners.

Let:
- A = (cos\Theta, sin\Theta) * (W/2)
- O = (-A_{y}, A_{x}) * (H/2)
- C_{1} (Top right)    =   A + O
- C_{2} (Top left)     = (-A) + O
- C_{3} (Bottom left)  =  -C_{1}
- C_{4} (Bottom right) =   -C_{2}

This is how the function would look in Luau

#+begin_src lua
  local function GetRectCorners(width: number, height: number, angle: number, origin: Vector2): (Vector2, Vector2, Vector2, Vector2)
  	local cos, sin = math.cos(angle), math.sin(angle)
  	local adjacent  = Vector2.new(cos, sin) * (width/2)
  	local opposite = Vector2.new(-sin, cos) * (height/2)

  	local C1 = adjacent + opposite
  	local C2 = -adjacent + opposite
  	
  	return
  		-- C₁
  		origin + C1,
  		origin + C2,
  		origin - C1,
  		origin - C2
  end
#+end_src

* Line segment intersections

What does it mean for two lines to intersect? Lets say we have a line L with the points {(1,0), (-1, 0)}. We want to check if these points cross Y axis. In order for that to happen, these points must be on opposite sides of the y-axis. Basically, one point needs to be on the left side, and the other on the right, If they are on the same side, they cannot cross each other. In this case, the line L does cross the y-axis because they are on opposite sides. We also know the y-axis crosses the L because it is infinite, so L and the y-axis intersect each other.

We have a line segment L_{1}, and a y-axis aligned line-segment L_{2}.

Let:
- L_{1} = {p_{1}, p_{2}}
- L_{2} = {p_{3}, p_{4}}

We need to check if the points in L_{2} are on the on the left and right of L_{1}. We can use the cross product of two 2D vectors to determine this. The cross product of two 2D vectors, A and B, return a signed scalar value. We can use this signed value to detect if B is clockwise (right) or counterclockwise (left) from A.

The cross product two 2D vectors is defined as:
Cross(P_{1}, P_{2}) = P_{1}.x * P_{2}.y - P_{1}.y * P_{2}.x

So the function to find if L_{2} crosses L_{1} is:

Cross(p_{2} - p_{1}, p_{3} - p_{1}) > 0
~=
Cross(p_{2} - p_{1}, p_{4} - p_{1}) > 0

We subtract p_{1} from the values so they have a common origin. If they are AA or BB, it means they are on the same side, therefore they do not cross. If they are AB or BA, they are different, therefore they do cross.

Now we need to check the other way, if the points in L_{1} are on the on the left and right of L_{2}. Since L_{2} is y-axis aligned, we can just check if the x components of p_{1} and p_{2} are on the left and right of x of. It doesn't even matter which x we use from p_{3} or p_{4} in this case, since they are both the same.

p_{1}.x < p_{3}.x
~=
p_{2}.x < p_{3}.x

If we wanted to check the same for an x-axis aligned line-segment, we just swap the x values for y.

Lets look at how we would implement these functions in Luau:

#+begin_src lua
  local function LineIntersectsXAALine(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2): boolean
  	local fixed_p2 = p2 - p1 
      return
  		-- L₂ crosses L₁
  		fixed_p2:Cross(p3 - p1) > 0
  		~=
  		fixed_p2:Cross(p4 - p1) > 0
  		and
  		-- L₁ crosses L₂
  		p1.y > p4.y
  		~=
  		p2.y > p4.y
  end

  local function LineIntersectsYAALine(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2): boolean
  	local fixed_p2 = p2 - p1 
      return
  		-- L₂ crosses L₁
  		fixed_p2:Cross(p3 - p1) > 0
  		~=
  		fixed_p2:Cross(p4 - p1) > 0
  		and
  		-- L₁ crosses L₂
  		p1.x > p4.x
  		~=
  		p2.x > p4.x
  end

  local function LineIntersectsLine(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2): boolean
  	local fixed_p2 = p2 - p1
  	local fixed_p4 = p4 - p3
      return
  		-- L₁ crosses L₂
  		fixed_p2:Cross(p3 - p1) > 0
  		~=
  		fixed_p2:Cross(p4 - p1) > 0
  		and
  		-- L₂ crosses L₁
  		fixed_p4:Cross(p1 - p3) > 0
  		~=
  		fixed_p4:Cross(p2 - p3) > 0
  end
#+end_src

* (Axis Aligned) Rectangle collisions

This section will cover 3 types of rectangle collisions.

1. Point in rectangle
2. Line in rectangle
3. Rectangle in rectangle

** Point in rectangle
   
The space to query in a unrotated rectangle is X_{min} X_{max},  and Y_{min} Y_{max}.

To test if a point is within a unrotated rectangle:

P_{x} > X_{min}
and
P_{x} < X_{max}
and
P_{y} > Y_{min}
and
P_{y} < Y_{max}

Where
- X_{min} is the x value of any point on the left side.
- X_{max} is the x value of any point on the right side.
- Y_{min} is the y value of any point on the bottom side.
- Y_{max} is the y value of any point on the top side.

In Luau:
#+begin_src lua
  local function QueryPointInAARect(point: Vector2, rect: S_Rect): boolean
  	local tl = rect.topLeft
  	local br = rect.bottomRight
  	return 
  		point.X > tl.X
  		and point.X < br.X
  		and point.Y > br.Y
  		and point.Y < tl.Y
  end
#+end_src

** Line in rectangle

There are two ways to be considered "colliding" with a rectangle.

1. Be within the space defined by the rectangle.
2. Intersect the space defined by the rectangle.
   
Two is important. If we have a cross (example figure below), where neither points are within the space of a rectangle, we can still have a collision.

Although there are two ways to collide, there may be times where you might only want to detect intersections, like with raycasts. But for this implementation, I will cover both.

For both of the collision cases, we already functions defined that we can reuse to make define function. For case 1, we can use QueryPointInAARect. And for case 2, because we know each line of the rectangle is axis aligned, we can use LineIntersects(X/Y)AALine.

In Luau:
#+begin_src lua
  local function QueryLineInAARect(p1: Vector2, p2: Vector2, rect: S_Rect): boolean
  	local tl = rect.topLeft
  	local tr = rect.topRight
  	local bl = rect.bottomLeft
  	local br = rect.bottomRight

  	return
  		-- Check if within the rect
  		QueryPointInURect(p1, rect)
  		or QueryPointInURect(p2, rect)
  	-- Check if intersect rect
  		or LinesIntersectsYAALine(p1, p2, tl, bl)
  		or LinesIntersectsYAALine(p1, p2, tr, br)
  		or LinesIntersectsXAALine(p1, p2, tl, tr)
  		or LinesIntersectsXAALine(p1, p2, bl, br)
  end
#+end_src


** Rectangle in rectangle

We have two axis aligned rectangles, R_{1} and R_{2}. We know the space defined by these rectangles is between x_{min} x_{max}, and y_{min} y_{max}. To check if the space between the two rectangles overlap, we can check:

min_{1} < max_{2}
and
max_{1} > min_{2}

for the x and y of the min and max of R_{1} and R_{2}. If the min is past the max, it is too far right, and if the max is behind the min, then it is too far left.

#+begin_src lua
  local function QueryAARectInAARect(r1: S_Rect, r2: S_Rect): boolean
  	local tl1, br1 = r1.topLeft, r1.bottomRight
  	local tl2, br2 = r2.topLeft, r2.bottomRight
  	return
  		-- Check collision in x space
  		tl1.X < br2.X
  		and
  		br1.X > tl2.X
  		and
  		-- Check collision in y space
  		tl1.Y < br2.Y
  		and
  		br1.Y > tl2.Y
  end
#+end_src

* Collisions with different shapes

* (rotated) Rectangle collisions

Unless physics is important to your gameplay, AABB should be preferred. Not only is it faster, but it is easier to understand and implement. Most 2D games will use AABB for this reason.

** Point in rectangle

This is actually pretty simple. Rather than dealing with a rotated rectangle, we can just rotate the point by the rectangle's angle.

#+begin_src lua
  local function QueryPointInRect(point: Vector2, rect: S_Rect): boolean
  	local rotated_point = RotatePointAroundPoint(point, rect.origin, rect.angle)
  	return QueryPointInAARect(rotated_point, rect)
  end
#+end_src

** Line in rectangle

We use the same technique as Point in rectangle.

#+begin_src lua
  local function QueryLineInRect(p1: Vector2, p2: Vector2, rect: S_Rect)
  	local rotated_p1 = RotatePointAroundPoint(p1, rect.origin, rect.angle)
  	local rotated_p2 = RotatePointAroundPoint(p2, rect.origin, rect.angle)
  	return QueryLineInAARect(rotated_p1, rotated_p2, rect)
  end
#+end_src

** Rectangle in rectangle

There are two different ways to handle rotated rectangle collisions. One is using the most popular method, SAT (Seperating Axis)
